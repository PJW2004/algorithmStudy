# "테트로미노 하나를 놓는다" 가 가장 중요.
# 모든 경우의 수를 계산해보면 된다.
# 시간 제한은 2초.
# 폴리오미노를 4개 이어붙여서 만든 도형으로 만든다.
tetromino = (
    # 일자
    ((0,1), (0,2), (0,3)),
    ((1,0), (2,0), (3,0)),
    
    # 정사각형
    ((0,1), (1,0), (1,1)),
    
    # ㄱ 자
    ((1,0), (1,1), (1,2)),
    ((0,1), (1,0), (2,0)),
    ((0,1), (0,2), (1,2)),
    ((1,0), (2,0), (2,-1)),
    ((0,1), (0,2), (-1,2)),
    ((1,0), (2,0), (2,1)),
    ((0,1), (0,2), (1,0)),
    ((0,1), (1,1), (2,1)),
    
    # ㄱㄴ 자
    ((0,1), (-1,1), (-1,2)),
    ((1,0), (1,1), (2,1)),
    ((0,1), (1,1), (1,2)),
    ((1,0), (1,-1), (2,-1)),

    # ㅗ 자
    ((0,1), (0,2), (-1,1)),
    ((0,1), (0,2), (1,1)),
    ((1,0), (2,0), (1,1)),
    ((1,0), (2,0), (1,-1)),
)

n,m = map(int, input().split()) # 미리 입력 받음.
paper = [list(map(int,input().split())) for _ in range(n)]
max_count = 0
for i in range(n):
    for j in range(m):
        for polyomino in tetromino:
            ok = True # 적용이 되는지
            s = paper[i][j]
            for dx, dy in polyomino:
                x, y = i+dx, j+dy # 블럭 배치
                if 0 <= x < n and 0 <= y < m:
                    s += paper[x][y] # 블럭의 정수 빼오기
                else:
                    ok = False
                    break # 적용 안되면 패스
            if ok and max_count < s: # 최댓값이면 갱신
                max_count = s
print(max_count)